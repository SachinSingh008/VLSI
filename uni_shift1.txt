library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity uni_shift1 is
			port(reset, si, clk, load : in STD_LOGIC;
			pi :in STD_LOGIC_VECTOR ( 3 downto 0);
			po: out STD_LOGIC_VECTOR ( 3 downto 0);
			mode : in STD_LOGIC_VECTOR ( 1 downto 0);
			so : out STD_LOGIC
			);
	end uni_shift1;
architecture Behavioral of uni_shift1 is
	signal temp: std_logic_vector(3 downto 0):="0000";
	signal clk_s: std_logic_vector(23 downto 0):=(others=>'0');
begin
--Count&lt;= clk_s(22);
	Process(clk)
		Begin
			If rising_edge (clk) then
			Clk_s<=clk_s+ '1';
			End if;
	End process;--
	Process(clk_s(22), mode, si, load, reset)
		Begin
			If reset='1' then temp<="0000"; po<="0000"; so<='0';
				Elsif rising_edge(clk_s(22)) then
			Case mode is
				--SISO
				When "00"=> temp(3 downto 1) <= temp(2 downto 0);
				Temp(0)<=si;
				so<=temp(3);

				--SIPO
				When "01"=> temp(0)<=si;
				temp(3 downto 1) <= temp(2 downto 0);
				po<=temp;

				--PIPO
				When "10"=> if load='1' then 
				temp<=pi;
				else 
				po<= temp; 
				end if;
				--PISO
				When "11"=> if(load='1') then
				Temp(3 downto 0)<=pi(3 downto 0);
				Else
				so<=temp(3);
				temp(3 downto 1)<= temp(2 downto 0);
				temp(0)<='0';

				end if;
			when others=> null;
   			end case;
			end if;
	end process;
end behavioral;




---------------------------Simulation---------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
 
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--USE ieee.numeric_std.ALL;
 
ENTITY test IS
END test;
 
ARCHITECTURE behavior OF test IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT uni_shift1
    PORT(
         reset : IN  std_logic;
         si : IN  std_logic;
         clk : IN  std_logic;
         load : IN  std_logic;
         pi : IN  std_logic_vector(3 downto 0);
         po : OUT  std_logic_vector(3 downto 0);
         mode : IN  std_logic_vector(1 downto 0);
         so : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal reset : std_logic := '0';
   signal si : std_logic := '0';
   signal clk : std_logic := '0';
   signal load : std_logic := '0';
   signal pi : std_logic_vector(3 downto 0) := (others => '0');
   signal mode : std_logic_vector(1 downto 0) := (others => '0');

 	--Outputs
   signal po : std_logic_vector(3 downto 0);
   signal so : std_logic;

   -- Clock period definitions
   constant clk_period : time := 10 ns;
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: uni_shift1 PORT MAP (
          reset => reset,
          si => si,
          clk => clk,
          load => load,
          pi => pi,
          po => po,
          mode => mode,
          so => so
        );

   -- Clock process definitions
   clk_process :process
   begin
		clk <= '0';
		wait for clk_period/2;
		clk <= '1';
		wait for clk_period/2;
   end process;
 

   -- Stimulus process
   stim_proc: process
   begin		
      -- hold reset state for 100 ns.
      wait for 100 ns;	
		
		-- Initialize
        reset <= '1';
        wait for 100 ns;
        reset <= '0';

        mode <= "10";   -- PIPO mode
        pi <= "1010";
        load <= '1';    -- load data
        wait for 100 ns;
        load <= '0';    -- hold
        wait for 100 ns;

        mode <= "01";                --SIPO
        si <= '0'; wait for 100 ns;
        si <= '1'; wait for 100 ns;
        si <= '0'; wait for 100 ns;
        si <= '1'; wait for 100 ns;

        mode <= "00";                --SISO
        si <= '1'; wait for 100 ns;
        si <= '0'; wait for 100 ns;
        si <= '1'; wait for 100 ns;
        si <= '1'; wait for 100 ns;

        mode <= "11";                --PISO
        pi <= "1101";
        load <= '1'; wait for 100 ns;
        load <= '0'; wait for 400 ns;

      
      wait;
   end process;

END;
